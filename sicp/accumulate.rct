#lang racket
(define nil '())
(define (enumerate-interval init end)
  (if (> init end)
      '()
      (cons init (enumerate-interval (+ 1 init) end))))
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))
(define (map p seq)
  (accumulate (lambda (x y) (cons (p x) y )) '() seq))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length seq)
  (accumulate (lambda (x y) (+ 1 y)) 0 seq))
(define (horner-eval x seq)
  (accumulate (lambda (this-coeff higher-coeff) (+ (* x higher-coeff) this-coeff))
              0
              seq))
(define (count-leaves t)
  (accumulate (lambda (x y) (if (pair? x) (+ y 1) (+ y x))) 0 (map (lambda (x) (if (pair? x) (count-leaves x) (if (null? x) 0 1))) t)))
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
(define (nums n)
  (if (< n 1)
      '()
      (cons n (nums (- n 1)))))
(define (unique-pairs n)
  (if (< n 2)
      '()
      (append (map (lambda (x) (cons n x)) (nums (- n 1))) (unique-pairs (- n 1)))))

(define (make-pair-sum pair)
  (list (car pair) (cdr pair) (+ (car pair) (cdr pair))))

(define (prime? x)
  (define (iter guess num)
    (cond ((= guess num) true)
          ((= 0 (remainder num guess)) false)
          (else (iter (+ 1 guess) num))))
  (iter 2 x))
        

(define (prime-sum? pair)
  (prime? (+ (car pair) (cdr pair))))


(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))

(define (safe? k positions)
  (define (check next x seq)
    (cond ((null? seq) #true)
          ((= (car seq) x) #false)
          (else (check next (next x) (cdr seq)))))
  (if (null? positions)
      #true
      (and (check (lambda (x) (- x 1)) (- (car positions) 1) (cdr positions))
           (check (lambda (x) x) (car positions) (cdr positions))
           (check (lambda (x) (+ x 1)) (+ (car positions) 1) (cdr positions)))))
(define empty-board '())
(define (adjoin new-row k rest-of-queues)
  (append (list new-row) rest-of-queues))
(define (flatmap func seqs)
  (accumulate append nil (map func seqs)))
(define (queens board-size)
  (define (queen-cols k)
    (if (= 0 k)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queues)
            (map (lambda (new-row)
                   (adjoin new-row k rest-of-queues))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
